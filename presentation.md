class: center, middle

# Swifty Core Data

####How I used protocol and protocol extension to help with Core Data

???

* INTRODUCTION
* AGENDA

1. NSManagedObject extensions: Protocol extensions to the rescue
How I used protocol extension to extend data layer classes and have them some commonly used functions.
2. Using Protocols to hide away persistence layer
3. Testing the created protocols

---
class: middle

```
class Task: NSManagedObject {
  @NSManaged var id: NSNumber
  @NSManaged var text: String
}
```

???

* sample Class
* is a managed object
* created in xcdatamodel
* generated by xcode
* has id, text
* procedure not different for complex classes

---
class: middle

```
extension Task {
  class func object(managedObjectContext: NSManagedObjectContext,
                    predicate: NSPredicate?)
                    -> Task? {
    let fetchRequest = NSFetchRequest(entityName: "Task")
    fetchRequest.predicate = predicate
    guard let result = try? managedObjectContext.executeFetchRequest(fetchRequest) else {
      print("Error getting object of entity \(self)")
      return nil
    }
    assert(result.count <= 1)
    return result.first as? Task
  }
}
```

.footnote[.simple[*] Not the most optimal implementation]

???

* define simple method
* method returns an optional Task
* input parameters are moc and predicate
* not the most optimal implementation
* using extension because the class definition was generated by xcode

---
class: middle

```
extension Task {
* class func object(managedObjectContext: NSManagedObjectContext,
                    predicate: NSPredicate?)
                    -> Task? {
    let fetchRequest = NSFetchRequest(entityName: "Task")
    fetchRequest.predicate = predicate
    guard let result = try? managedObjectContext.executeFetchRequest(fetchRequest) else {
      print("Error getting object of entity \(self)")
      return nil
    }
    assert(result.count <= 1)
    return result.first as? Task
  }
}
```

####1. This function is tied to `NSManagedObjectContext` and would need a rewrite if we decide to change the persistence layer.

???
* tied to core data as persistence layer

---
class: middle

```
extension Task {
  class func object(managedObjectContext: NSManagedObjectContext,
                    predicate: NSPredicate?)
*                   -> Task? {
    let fetchRequest = NSFetchRequest(entityName: "Task")
    fetchRequest.predicate = predicate
    guard let result = try? managedObjectContext.executeFetchRequest(fetchRequest) else {
      print("Error getting object of entity \(self)")
      return nil
    }
    assert(result.count <= 1)
*   return result.first as? Task
  }
}
```

####2. This function would need to be copied to any other class too that requires it.

???
* simple copy and paste won't work

---
class: middle

```
extension Task {
  class func object(managedObjectContext: NSManagedObjectContext,
                    predicate: NSPredicate?)
                    -> Task? {
*   let fetchRequest = NSFetchRequest(entityName: "Task")
    fetchRequest.predicate = predicate
    guard let result = try? managedObjectContext.executeFetchRequest(fetchRequest) else {
      print("Error getting object of entity \(self)")
      return nil
    }
    assert(result.count <= 1)
    return result.first as? Task
  }
}
```

####3. And when moving, remember to change the entity name, the compiler won't help you there.

???
* even fetch request requires your class's name
* as referenced in model

---
class: center, middle

##So we have a non-reusable strongly tied method

---
class: center, middle

##Let's fix it...

---
class: middle

```
extension NSManagedObject {
  class func managedObject(managedObjectContext: NSManagedObjectContext,
                           predicate: NSPredicate?)
                           -> NSManagedObject? {
    let fetchRequest = NSFetchRequest(entityName: "Task")
    fetchRequest.predicate = predicate
    guard let result = try? managedObjectContext.executeFetchRequest(fetchRequest) else {
      print("Error getting object of entity \(self)")
      return nil
    }
    assert(result.count <= 1)
    return result.first as? NSManagedObject
  }
}
```

???

First attempt
####We move this function to an extension on `NSManagedObject` instead.

* available to all managed objects

---
class: middle, center

###*Easy, Right?*

---
class: middle

```
*extension NSManagedObject {
  class func managedObject(managedObjectContext: NSManagedObjectContext,
                           predicate: NSPredicate?)
                           -> NSManagedObject? {
    let fetchRequest = NSFetchRequest(entityName: "Task")
    fetchRequest.predicate = predicate
    guard let result = try? managedObjectContext.executeFetchRequest(fetchRequest) else {
      print("Error getting object of entity \(self)")
      return nil
    }
    assert(result.count <= 1)
    return result.first as? NSManagedObject
  }
}
```

####1. Every `NSManagedObject` class gets it, by default, even if we don't want it to.

---
class: middle

```
extension NSManagedObject {
* class func managedObject(managedObjectContext: NSManagedObjectContext,
                           predicate: NSPredicate?)
                           -> NSManagedObject? {
    let fetchRequest = NSFetchRequest(entityName: "Task")
    fetchRequest.predicate = predicate
    guard let result = try? managedObjectContext.executeFetchRequest(fetchRequest) else {
      print("Error getting object of entity \(self)")
      return nil
    }
    assert(result.count <= 1)
    return result.first as? NSManagedObject
  }
}
```

####2. We are still tied up with Core Data.
####Function `managedObject` is not available to classes not using Core Data as persistence layer.

---
class: middle

```
extension NSManagedObject {
  class func managedObject(managedObjectContext: NSManagedObjectContext,
                           predicate: NSPredicate?)
*                          -> NSManagedObject? {
    let fetchRequest = NSFetchRequest(entityName: "Task")
    fetchRequest.predicate = predicate
    guard let result = try? managedObjectContext.executeFetchRequest(fetchRequest) else {
      print("Error getting object of entity \(self)")
      return nil
    }
    assert(result.count <= 1)
    return result.first as? NSManagedObject
  }
}
```

####3. The return type of the function is `NSManagedObject`. So whenever you want to use it, you type cast it.

```
Task.managedObject(mainManagedObjectContext, predicate: nil)
* as! Task
```

---
class: middle

```
extension NSManagedObject {
  class func managedObject(managedObjectContext: NSManagedObjectContext,
                           predicate: NSPredicate?)
                           -> NSManagedObject? {
*   let fetchRequest = NSFetchRequest(entityName: "Task")
  fetchRequest.predicate = predicate
  guard let result = try? managedObjectContext.executeFetchRequest(fetchRequest) else {
    print("Error getting object of entity \(self)")
    return nil
  }
  assert(result.count <= 1)
  return result.first as? NSManagedObject
}
```

####4. That is *NOT* the name of all our entities.

---
class: center, middle

###Hmm, so extending NSManagedObject wasn't a very good solution..

---
class: middle, center

###Easy, Right?
## *YES*

---
class: middle, center

###Works?
## *NO*

???
*I wouldn't have added so many negative points to my solution! So obvious ðŸ˜*

---
class: middle, center

##Let us fix the *entity name* issue first

---
class: middle

```
extension NSManagedObject {
  class func name() -> String {
    return NSStringFromClass(self)
*   .componentsSeparatedByString(".").last! // *
  }
}
```

.footnote[.simple[*] Module name is prepended to string representations of classes in swift]

???
* namespacing via module name

---
class: middle

```
extension NSManagedObject {
  class func managedObject(managedObjectContext: NSManagedObjectContext,
                           predicate: NSPredicate?)
                           -> NSManagedObject? {
* let fetchRequest = NSFetchRequest(entityName: name())
  fetchRequest.predicate = predicate
  guard let result = try? managedObjectContext.executeFetchRequest(fetchRequest) else {
    print("Error getting object of entity \(self)")
    return nil
  }
  assert(result.count <= 1)
  return result.first as? NSManagedObject
}
```

---
class: middle, center

###*Entity name issue solved*

##ðŸ˜ª

---
class: middle, center

###Back to original problem of getting managed classes to answer

##`object`

---
class: center, middle

**Enter,**

#Protocol Extensions
##Protocol Extensions
###Protocol Extensions
...

---
class: center, middle

###But first we need a protocol!

---
class: center, middle

###Let us start by naming the protocol

---
class: center, middle

#Entity

???
* Dictionary on mac defines:
  * a thing with distinct and independent existence:
* we chose because database calls them entities

---
class: center, middle

#ðŸ‘
###Because naming is important
![](assets/names.png)

Credits: [xkcd](https://xkcd.com/302/)

???
Some well deserved applause for myself

---
class: middle, center

###Any object that wants to work with our model layer is now an

#`Entity`

---
class: middle

```
protocol Entity {
}
```

---
class: middle

```
protocol Entity {
  static func name() -> String
}
```

The first requirement of the protocol is to have a name.

---
class: middle, center

###We know what this method has to do for `NSManagedObject`

???
remind about name slide

---
class: middle

####Let us add this to an extension, *on protocol*.

```
extension Entity
  where Self: NSManagedObject {
  static func name() -> String {
    return NSStringFromClass(self)
    .componentsSeparatedByString(".").last!
  }
}
```

---
class: middle

```
extension Entity
* where Self: NSManagedObject {
  static func name() -> String {
    return NSStringFromClass(self)
    .componentsSeparatedByString(".").last!
  }
}
```

???

* bound to NSManagedObject only
* Self represents the conforming class

---
class: middle

####  Next we declare the method `object`
```
protocol Entity {
  static func object(managedObjectContext: NSManagedObjectContext,
                     predicate: NSPredicate?)
                     -> NSManagedObject?
}
```

???

* why is return type NSManagedObject

---
class: middle

```
protocol Entity {
  static func object(managedObjectContext: NSManagedObjectContext,
                     predicate: NSPredicate?)
*                    -> Self?
}
```

???

* returns instance of Self type

---
class: middle

```
*Task
.object(mainManagedObjectContext, predicate: nil)
```

???
The returned object is now of correct type.
---
class: middle, center

##Still using `NSManagedObjectContext`!

---
class: middle, center

##Why?

???

* want to abstract out persistence layer
* note: we need to have a reference of persistence layer to implement the method

---
class: center, middle

##Welcome associatedType

???
* Swift book
  * â€œAn associated type gives a placeholder name to a type that is used as part of the protocol.â€
* for generic code

---
class: middle

```
protocol Entity {
* associatedType Context
* static func object(context: Context,
                     predicate: NSPredicate?)
                     -> Self?
}
```

???
* prediates are persistence layer agnostic
* conforming class defines Context

---
class: center, middle

##Finally no trace of Core data!

???

---
class: middle

```
protocol Entity {
  associatedType Context
  static func object(predicate: NSPredicate?,
*                    context: Context)
                     -> Self?
}
```


The order of the parameters is of significance here.

Apple keeps context as first param and I have always found increased readability when I follow what Apple is doing. Just FWIW note.


```
func CGContextSetFlatness(_ c: CGContext?, _ flatness: CGFloat)
func CGContextSetLineDash(_ c: CGContext?, _ phase: CGFloat, _ lengths: UnsafePointer<CGFloat>, _ count: Int)
func CGContextSetInterpolationQuality(_ c: CGContext?, _ quality: CGInterpolationQuality)
//...
```

???

* small Break
* follow naming paradigms followed by Apple
* then our code looks nice playing with Cocoa

---
class: middle, center

###Moving on

???
break over
---
class: middle

```
extension Entity where Context == NSManagedObjectContext {
  static func object(context: Context, predicate: NSPredicate?) -> Self? {
  let req = NSFetchRequest(entityName: name())
  req.predicate = predicate
  guard let result = try? context.executeFetchRequest(req) else {
    logger.error("Error getting object of entity \(self)")
    return nil
  }
  assert(result.count <= 1)
  return result.first as? Self
  }
}
```

???

Move to next slides for explanation

---
class: middle, center

###Too much code
##Break it

---
class: middle

```
extension Entity where Context == NSManagedObjectContext {
```

???
* extend protocol
* when context is NSManagedObjectContext

---
class: middle

```
static func object(context: Context, predicate: NSPredicate?)
-> Self? {
```

???
* method implementation
* context is NSManagedObjectContext from where clause
* autocompletion works

---
class: middle

```
let req = NSFetchRequest(entityName: name())
```

???
* name from protocol

---
class: middle

```
req.predicate = predicate
guard let result = try? context.executeFetchRequest(req) else {
  logger.error("Error getting object of entity \(self)")
  return nil
}
assert(result.count <= 1)
```

???
* execute fetch request
---
class: middle

```
return result.first as? Self
```

???
Explain type cast required because `executeFetchRequest` returns `[AnyObject]`.

---
class: middle

```
extension Entity where Context == NSManagedObjectContext {
  static func object(context: Context, predicate: NSPredicate?) -> Self? {
  let req = NSFetchRequest(entityName: name())
  req.predicate = predicate
  guard let result = try? context.executeFetchRequest(req) else {
    logger.error("Error getting object of entity \(self)")
    return nil
  }
  assert(result.count <= 1)
  return result.first as? Self
  }
}
```

???
Look at this again to see complete implementation

---
class: middle

```
protocol Entity {
  associatedtype Context
  static func name() -> String
  static func object(context: Context,
                     predicate: NSPredicate?) -> Self?
}
```

???
protocol

---
class: middle, center

# Conformance

---
class: middle

```
extension Task: Entity {
  typealias Context = NSManagedObjectContext
}
```

???
* picks default implementation for `object`

---
class: middle, center

##Sweet!
##ðŸ‘Œ

---
class: middle, center

##Time to see imperfections in our world
#ðŸ™„
---
class: middle, center

####Gotcha #1

###An associatedType can not be fulfilled by the protocol extension

???
* I would like to give a typealias based on my where clause.
* guess the compiler has some edge cases on that
* thus not there

---
class: middle

```
extension Entity where Self: NSManagedObject {
  typealias Context = NSManagedObjectContext
}
```

---
class: middle

```
extension Task: Entity {
  typealias Context = NSManagedObjectContext
}
```

---
class: middle, center

####Gotcha #2

###We can not have non-final classes
###conform to `Entity`

---
class: middle, center

![](assets/ProtocolInheritence.png)

####Since the protocol extension method returns an instance of type `Self?`, the Swift compiler would not allow any non-final class to use this default implementation!

???
* not an issue if no protocol extension
* protocol extension returning `Self`
* Protocol P
* A conforms to P
* B is a subclass of A
* `object` is unable to say, what is `Self`?

---
class: middle, center

##Override?

???
* protocol extension methods are default implementation
* when where clause met
* the implementations can be overriden
* by conforming classes
* without `override` annotation

---
class: middle, center

###Now any class conforming to the protocol defines its own context to use.

---
class: middle, center

###So your `Entity` could be using `NSUserDefaults` as Context and the protocol would not bat an eye!

???
* implementation for different persistence layer

---
class: middle

```
final class Account: Entity {
  typealias Context = NSUserDefaults

  static func name() -> String {
    return "KeyForAccountInUserDefaults"
  }

  class func object(context: Context,
                    predicate: NSPredicate?) -> Account? {
    return context.objectForKey(name()) as? Account
  }
}
```

???
Explain how the persistence layer has been abstracted out. This class's object
can now be kept in an array [Entity] and worked on by functions.

---
class: middle, center

#Testing

---
class: middle, center

###No changes to existing tests

---
class: middle, center

###Except name changes maybe
###ðŸ¤”

???
(to the new protocol methods)

Example: managedObject -> object

---
class: middle, center

###The tests can choose to ignore the protocol totally

???
The conforming classes/structs can be tested with the methods they implement.
name changes maybe again

---
class: middle

```
func testName() {
  XCTAssertEqual("Account", Account.name())
}
```

???
Example of protocol being ignored
---
class: middle

```
func testObjectSavedIsReturned() {
  let moc = testContext()
  guard let task = NSEntityDescription
    .insertNewObjectForEntityForName(Task.name(),
                                     inManagedObjectContext: moc) as? Task
    else {
      assertionFailure()
      return
  }
  task.id = NSNumber(unsignedInt: arc4random())
  moc.saveContext()

* guard let retrievedTask = Task.object(moc, predicate: nil) else {
    assertionFailure()
    return
  }
  XCTAssertEqual(retrievedTask.id, task.id)
}
```

???
might have named the function account before which changed to this.

---
class: middle, center

###Apology ðŸ˜·
###Getting name for a `NSManagedObject` can also be done by

```
String(Class_Name)
```

???
* getting name for managed object
* Module name is not prepended to class name this way.

---
class: middle, center

###Thanks!
###ðŸ––

You can get the presentation and test project at
####https://www.github.com/ayushgoel/wtb

???
* not watched Star Trek. Just picked up to show off.
